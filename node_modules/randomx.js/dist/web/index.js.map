{
  "version": 3,
  "sources": ["../../../src/wasm_prefix.ts", "wasm-stub:dataset.wasm", "wasm-stub:vm.wasm", "../../../src/dataset/dataset.ts", "../../../src/detect/detect.ts", "../../../src/vm_single/vm.ts"],
  "sourcesContent": ["declare var INSTRUMENT: number\n\nexport function locate_import(binary: Uint8Array, needle: string): number {\n\t// the import section is near the start, no need to step over the entire binary\n\t// indexOf doesn't work on Uint8Array\n\n\tconst needle_binary = new TextEncoder().encode(needle)\n\tconst needle_length = needle_binary.length\n\tlet found = false\n\tlet p = 0\n\tfor (; p < binary.length; p++) {\n\t\tfound = true\n\t\tfor (let i = 0; i < needle_length; i++) {\n\t\t\tif (binary[p + i] !== needle_binary[i]) {\n\t\t\t\tfound = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (found) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif (INSTRUMENT && !found) {\n\t\tthrow new Error('Import not found')\n\t}\n\n\tp += needle_length\n\n\treturn p\n}\n\nexport function u32p(buf: Uint8Array, p: number): [n: number, p: number] {\n\tlet num = 0\n\tlet shift = 0\n\twhile (true) {\n\t\tconst byt = buf[p++]\n\t\tnum |= (byt & 0x7f) << shift\n\t\tif (byt >> 7 === 0) {\n\t\t\tbreak\n\t\t} else {\n\t\t\tshift += 7\n\t\t}\n\t}\n\treturn [num, p]\n}\n\nexport function locate_section(binary: Uint8Array, section: number): [p: number, found: boolean] {\n\tlet im_found = false\n\tlet im = 8 // skip magic and version\n\twhile (im < binary.length) {\n\t\tif (binary[im] === section) {\n\t\t\tim_found = true\n\t\t\tbreak\n\t\t}\n\t\tim++\n\n\t\tconst [n, imp] = u32p(binary, im)\n\t\tim = imp + n\n\t}\n\n\treturn [im, im_found]\n}\n\n\nexport function adjust_imported_shared_memory(binary: Uint8Array, needle: string, shared: boolean) {\n\t// the import section is near the start, no need to step over the entire binary\n\t// indexOf doesn't work on Uint8Array\n\n\tlet p = locate_import(binary, needle)\n\n\t// 0x02 memtype\n\n\t// memtype ::= limits\n\t// limits  ::= 0x00 n:u32         => { min n }\n\t//           | 0x01 n:u32 m:u32   => { min n, max m }\n\t//           | 0x03 n:u32 m:u32   => { min n, max m, shared }\n\n\tif (INSTRUMENT && binary[p] !== 0x02) {\n\t\tthrow new Error('Expected memtype')\n\t}\n\tp += 1 // 0x02\n\n\tif (INSTRUMENT && binary[p] === 0x00) {\n\t\tthrow new Error('Cannot patch in place')\n\t}\n\n\tbinary[p] = shared ? 0x03 : 0x01\n}\n", "import wasm from \"dataset.wasm\"\n\t\t\t\t\t\texport default wasm\n\t\t\t\t\t\texport const wasm_pages = 4098\n", "import wasm from \"vm.wasm\"\n\t\t\t\t\t\texport default wasm\n\t\t\t\t\t\texport const wasm_pages = 33\n", "import { env_npf_putc } from '../printf/printf'\nimport { adjust_imported_shared_memory } from '../wasm_prefix'\n\n// @ts-ignore\nimport wasm, { wasm_pages } from 'dataset.wasm'\n\n// @ts-ignore\nimport vm_wasm from 'vm.wasm'\n\ndeclare var INSTRUMENT: number\n\nlet _vm_handle: WebAssembly.Module | null = null\n\ntype DatasetModule = {\n\tc(pages: number, is_shared: boolean): number\n\tK(key_length: number): number\n}\n\n// can be shared between threads safely if shared memory is enabled\n/* export type RxCache = {\n\tmemory: WebAssembly.Memory // backing ArrayBuffer or SharedArrayBuffer\n\tthunk: WebAssembly.Module // WASM JIT code\n\tvm: WebAssembly.Module // handle to memoised randomx VM, to avoid recomplilation when sent over threads\n\tK(K: number): number\n} */\n\nexport type RxCacheHandle = {\n\tmemory: WebAssembly.Memory\n\tthunk: WebAssembly.Module\n\tvm: WebAssembly.Module\n}\n\nexport class RxCache {\n\t/**\n\t * @internal\n\t */\n\tmemory: WebAssembly.Memory\n\t/**\n\t * @internal\n\t */\n\tthunk: WebAssembly.Module\n\t/**\n\t * @internal\n\t */\n\tvm: WebAssembly.Module\n\t/**\n\t * @internal\n\t */\n\texports: DatasetModule\n\n\t/**\n\t * @internal\n\t */\n\tconstructor(memory: WebAssembly.Memory, thunk: WebAssembly.Module, vm: WebAssembly.Module, exports: DatasetModule) {\n\t\tthis.memory = memory\n\t\tthis.thunk = thunk\n\t\tthis.vm = vm\n\t\tthis.exports = exports\n\t}\n\n\tget shared(): boolean {\n\t\treturn this.memory.buffer instanceof SharedArrayBuffer\n\t}\n\n\tget handle(): RxCacheHandle {\n\t\treturn {\n\t\t\tmemory: this.memory,\n\t\t\tthunk: this.thunk,\n\t\t\tvm: this.vm\n\t\t}\n\t}\n}\n\nfunction create_module(is_shared: boolean): [WebAssembly.Memory, DatasetModule] {\n\t// we cannot cache this module because we need to adjust the memory import\n\tadjust_imported_shared_memory(wasm, '\\x03env\\x06memory', is_shared) // patch in place\n\n\tconst memory = new WebAssembly.Memory({ initial: wasm_pages, maximum: wasm_pages, shared: is_shared })\n\tconst wm = new WebAssembly.Module(wasm)\n\n\tconst wi_imports: Record<string, Record<string, WebAssembly.ImportValue>> = {\n\t\tenv: {\n\t\t\tmemory\n\t\t}\n\t}\n\n\tif (INSTRUMENT) {\n\t\twi_imports.e = {}\n\t\twi_imports.e.ch = env_npf_putc\n\n\t\tif (INSTRUMENT == 2) {\n\t\t\twi_imports.e.b = function (){}\n\t\t}\n\t}\n\n\tconst wi = new WebAssembly.Instance(wm, wi_imports as Record<string, any>)\n\n\tconst exports = wi.exports as DatasetModule\n\treturn [memory, exports]\n}\n\nfunction initialise(K: Uint8Array, memory: WebAssembly.Memory, exports: DatasetModule, is_shared: boolean): RxCache {\n\tconst jit_begin = exports.c(wasm_pages, is_shared)\n\tconst key_buffer = new Uint8Array(memory.buffer, jit_begin, 60)\n\tkey_buffer.set(K)\n\n\tconst jit_size = exports.K(K.length) // long blocking\n\tconst jit_buffer = new Uint8Array(memory.buffer, jit_begin, jit_size)\n\n\tif (!_vm_handle) {\n\t\t_vm_handle = new WebAssembly.Module(vm_wasm)\n\t}\n\n\treturn new RxCache(memory, new WebAssembly.Module(jit_buffer), _vm_handle, exports)\n}\n\ntype RxCacheOptions = { shared?: boolean }\n\nexport function randomx_init_cache(K: string | Uint8Array | undefined | null, cache: RxCache): RxCache\nexport function randomx_init_cache(K?: string | Uint8Array | undefined | null, conf?: RxCacheOptions | undefined | null): RxCache\n\nexport function randomx_init_cache(K?: string | Uint8Array | undefined | null, conf?: RxCache | RxCacheOptions | undefined | null): RxCache {\n\tif (typeof K === 'string') {\n\t\tK = new TextEncoder().encode(K)\n\t}\n\tK ??= new Uint8Array()\n\n\tif (K.length > 60) {\n\t\tthrow new Error('Key length is too long (max 60 bytes)')\n\t}\n\n\tif (conf instanceof RxCache) {\n\t\tconst cache = conf\n\t\treturn initialise(K, cache.memory, cache.exports, cache.shared)\n\t}\n\n\tconst is_shared = !!conf?.shared\n\tconst [memory, exports] = create_module(is_shared)\n\treturn initialise(K, memory, exports, is_shared)\n}\n\nexport type RxSuperscalarHash = (item_index: bigint) => [bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint]\n\nexport function randomx_superscalarhash(cache: RxCache | RxCacheHandle): RxSuperscalarHash {\n\tconst wi = new WebAssembly.Instance(cache.thunk, {\n\t\te: {\n\t\t\tm: cache.memory\n\t\t}\n\t})\n\n\ttype SuperscalarHashModule = {\n\t\td: RxSuperscalarHash\n\t}\n\n\tconst exports = wi.exports as SuperscalarHashModule\n\treturn exports.d\n}\n", "// @ts-ignore\nimport fma from './fma.wasm'\n// @ts-ignore\nimport simd from './simd.wasm'\n\nexport type JitFeature = number\n\nexport const JIT_BASELINE = 0 // SIMD and bulk memory instructions\nexport const JIT_RELAXED_SIMD = 1 // relaxed SIMD instructions\nexport const JIT_FMA = 2 // working fused multiply-add (assumes JIT_RELAXED_SIMD)\n\nexport function jit_detect(): JitFeature {\n\ttry {\n\t\tif (!WebAssembly.validate(simd)) {\n\t\t\tthrow null\n\t\t}\n\t} catch {\n\t\tthrow new Error('WebAssembly not available, or SIMD and bulk memory not supported. randomx.js requires these baseline features to run')\n\t}\n\t\n\ttry {\n\t\tconst wm = new WebAssembly.Module(fma)\n\t\tconst wi = new WebAssembly.Instance(wm)\n\n\t\t// TODO: FMA is disabled in the JIT as it doesn't work in all cases\n\t\tif ((wi.exports.d as () => number)()) {\n\t\t\treturn JIT_FMA | JIT_RELAXED_SIMD // working FMA\n\t\t}\n\t\treturn JIT_RELAXED_SIMD // no working FMA\n\t} catch {\n\t\treturn JIT_BASELINE // no relaxed SIMD\n\t}\n}\n\nfunction jit_feature_stringify(feature: JitFeature): string[] {\n\tconst s = []\n\n\tif (feature & JIT_RELAXED_SIMD) {\n\t\ts.push('relaxed-simd')\n\t}\n\n\tif (feature & JIT_FMA) {\n\t\ts.push('!fma')\n\t}\n\n\treturn s\n}\n\n// Node.js/v18.20.4 (linux x64) -------------------------------------------- AMD Ryzen 7 3800X 8-Core Processor\n// Bun/1.1.29 (linux x64) -------------------------------------------------- AMD Ryzen 7 3800X 8-Core Processor\n// Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0 -- Generic 16-Thread CPU\n\n// Generic 16-Thread CPU [rx/0+relaxed-simd+!fma] Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0\n\n// ignore this retardation - trying to get imports reliably per platform on esbuild is stupid\ndeclare var ENVIRONMENT: 'node' | 'browser'\ndeclare var FORMAT: 'cjs' | 'esm'\n\ndeclare var require: (module: string) => any\ndeclare var process: {\n\tisBun: boolean\n\tversion: string\n\tplatform: string\n\tarch: string\n}\ndeclare var Bun: {\n\tversion: string\n}\n\nlet node_os: any\n\n// @ts-ignore\nif (ENVIRONMENT === 'node') {\n\t// @ts-ignore\n\tif (FORMAT === 'esm') {\n\t\t// @ts-ignore\n\t\tnode_os = /* @__PURE__ */ await import('os')\n\t} else {\n\t\tnode_os = /* @__PURE__ */ require('os')\n\t}\n}\n\n// CPU [algo+features...] User-Agent\nexport function machine_id(feature: JitFeature): string {\n\tconst features = jit_feature_stringify(feature)\n\tlet ua: string | undefined\n\tlet cpu_model: string | undefined\n\n\tif (ENVIRONMENT === 'node') {\n\t\tif (!process.isBun) {\n\t\t\t// navigator added in Node v21.0.0, provide more accurate useragent anyway\n\t\t\tua = `Node.js/${process.version} (${process.platform} ${process.arch})`\n\t\t} else {\n\t\t\t// Bun has had navigator since release, provide more accurate useragent anyway\n\t\t\tua = `Bun/${Bun.version} (${process.platform} ${process.arch})`\t\n\t\t}\n\t\tcpu_model = node_os.cpus()[0].model as string\n\t}\n\t\n\tif (ENVIRONMENT === 'browser') {\n\t\tua = navigator.userAgent\n\t\tcpu_model = `Generic ${navigator.hardwareConcurrency}-Thread CPU`\n\t}\n\n\treturn `${cpu_model} [rx/0${features.length ? '+' : ''}${features.join('+')}] ${ua}`\n}\n", "import { randomx_superscalarhash, RxCache, type RxCacheHandle } from '../dataset/dataset'\nimport { jit_detect, machine_id, type JitFeature } from '../detect/detect'\nimport { env_npf_putc } from '../printf/printf'\nimport { timeit } from '../printf/timeit'\n\n// @ts-ignore\nimport { wasm_pages } from 'vm.wasm'\n\ndeclare var INSTRUMENT: number\n\nconst _feature: JitFeature = jit_detect()\n\nexport function randomx_machine_id() {\n\treturn machine_id(_feature)\n}\n\n// new virtual machine\nexport function randomx_create_vm(cache: RxCache | RxCacheHandle) {\n\ttype VmModule = {\n\t\tmemory: WebAssembly.Memory\n\n\t\ti(feature: JitFeature): number // returns scratch buffer\n\t\tI(is_hex: boolean): void\n\t\tH(data_length: number): number\n\t\tR(): number // iterate virtual machine\n\t\t// when INSTRUMENT\n\t\tb(ic: number, pc: number, mx: number, ma: number, sp_addr0: number, sp_addr1: number): void\n\t}\n\n\tconst SCRATCH_SIZE = 16 * 1024\n\n\n\tlet the_timeit: ReturnType<typeof timeit>\n\tconst memory = new WebAssembly.Memory({ initial: wasm_pages, maximum: wasm_pages })\n\tconst wi_imports: Record<string, Record<string, WebAssembly.ImportValue>> = {\n\t\tenv: {\n\t\t\tmemory\n\t\t}\n\t}\n\n\tif (INSTRUMENT) {\n\t\twi_imports.e = {}\n\t\twi_imports.e.ch = env_npf_putc\n\n\t\tif (INSTRUMENT == 2) {\n\t\t\tthe_timeit = timeit(memory)\n\t\t\tthe_timeit.timeit_init()\n\n\t\t\twi_imports.e.b = the_timeit.timeit\n\t\t}\n\t}\n\t\n\tconst wi = new WebAssembly.Instance(cache.vm, wi_imports as Record<string, any>)\n\tconst exports = wi.exports as VmModule\n\tconst scratch_ptr = exports.i(_feature)\n\tconst scratch = new Uint8Array(memory.buffer, scratch_ptr, SCRATCH_SIZE)\n\n\tconst superscalarhash = randomx_superscalarhash(cache)\n\tconst jit_imports: Record<string, Record<string, WebAssembly.ImportValue>> = {\n\t\te: {\n\t\t\tm: memory,\n\t\t\td: superscalarhash,\n\t\t}\n\t}\n\n\t// inspect the VM JIT code\n\tif (INSTRUMENT == 1) {\n\t\tjit_imports.e.b = exports.b\n\t} else if (INSTRUMENT == 2) {\n\t\tjit_imports.e.b = function () {}\n\t}\n\n\tfunction hash(H: Uint8Array | string, is_hex: boolean) {\n\t\tif (typeof H === 'string') {\n\t\t\tH = new TextEncoder().encode(H)\n\t\t}\n\n\t\t// install seed S from H\n\t\texports.I(is_hex)\n\t\tif (H.length <= SCRATCH_SIZE) {\n\t\t\t// most likely case\n\t\t\tscratch.set(H)\n\t\t\texports.H(H.length)\n\t\t} else {\n\t\t\tlet p = 0\n\t\t\twhile (p < H.length) {\n\t\t\t\tconst chunk = H.subarray(p, p + SCRATCH_SIZE)\n\t\t\t\tp += SCRATCH_SIZE\n\t\t\t\tscratch.set(chunk)\n\t\t\t\texports.H(chunk.length)\n\t\t\t}\n\t\t}\n\n\t\tlet jit_size: number\n\t\twhile (1) {\n\t\t\tjit_size = exports.R()\n\t\t\tif (jit_size === 0) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tconst jit_wm = new WebAssembly.Module(scratch.subarray(0, jit_size))\n\t\t\tconst jit_wi = new WebAssembly.Instance(jit_wm, jit_imports)\n\t\t\tconst jit_exports = jit_wi.exports as { d: () => void }\n\t\t\tjit_exports.d()\n\t\t}\n\n\t\tif (INSTRUMENT == 2) {\n\t\t\tthe_timeit.timeit_totals()\n\t\t}\n\t}\n\n\treturn {\n\t\tcalculate_hash(H: Uint8Array | string): Uint8Array {\n\t\t\thash(H, false)\n\t\t\treturn new Uint8Array(scratch.subarray(0, 32)) // Hash256\n\t\t},\n\t\tcalculate_hex_hash(H: Uint8Array | string): string {\n\t\t\thash(H, true)\n\t\t\treturn new TextDecoder().decode(scratch.subarray(0, 64)) // Hash256\n\t\t},\n\t}\n}\n"],
  "mappings": "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",
  "names": ["locate_import", "binary", "needle", "needle_binary", "needle_length", "found", "p", "i", "adjust_imported_shared_memory", "binary", "needle", "shared", "p", "locate_import", "dataset_default", "wasm_pages", "vm_default", "wasm_pages", "_vm_handle", "RxCache", "memory", "thunk", "vm", "exports", "create_module", "is_shared", "adjust_imported_shared_memory", "dataset_default", "wasm_pages", "wm", "wi_imports", "initialise", "K", "jit_begin", "jit_size", "jit_buffer", "vm_default", "randomx_init_cache", "conf", "cache", "randomx_superscalarhash", "JIT_BASELINE", "JIT_RELAXED_SIMD", "JIT_FMA", "jit_detect", "simd_default", "wm", "fma_default", "jit_feature_stringify", "feature", "s", "machine_id", "feature", "features", "jit_feature_stringify", "ua", "cpu_model", "_feature", "jit_detect", "randomx_machine_id", "machine_id", "randomx_create_vm", "cache", "the_timeit", "memory", "wasm_pages", "wi_imports", "exports", "scratch_ptr", "scratch", "superscalarhash", "randomx_superscalarhash", "jit_imports", "hash", "H", "is_hex", "p", "chunk", "jit_size", "jit_wm"]
}
